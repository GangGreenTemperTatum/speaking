<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Debug Markdown Rendering</title>
    <style>
        body {
            font-family: monospace;
            padding: 20px;
            background: #1a1a1a;
            color: #0f0;
        }
        .section {
            margin: 20px 0;
            padding: 15px;
            border: 1px solid #0f0;
            background: #0a0a0a;
        }
        .section h3 {
            margin-top: 0;
            color: #0ff;
        }
        pre {
            background: #000;
            padding: 10px;
            overflow-x: auto;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        .rendered {
            background: #fff;
            color: #000;
            padding: 15px;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <h1>Markdown Rendering Debug</h1>
    
    <div class="section">
        <h3>Test: CyberToronto December 2025</h3>
        <div id="status">Loading...</div>
    </div>

    <div class="section">
        <h3>Input (Body)</h3>
        <pre id="input"></pre>
    </div>

    <div class="section">
        <h3>Rendered Output</h3>
        <div class="rendered" id="output"></div>
    </div>

    <div class="section">
        <h3>Debug Info</h3>
        <pre id="debug"></pre>
    </div>

    <script>
        const logs = [];
        function log(msg) {
            logs.push(msg);
            document.getElementById('debug').textContent = logs.join('\n');
        }

        async function test() {
            try {
                log('Fetching README...');
                const response = await fetch('conferences/cyber-toronto/2025/december/README.md');
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                
                const markdown = await response.text();
                log(`Fetched ${markdown.length} characters`);
                
                // Parse like content-viewer.html does
                const lines = markdown.split('\n');
                let title = '';
                let description = '';
                let body = '';
                
                lines.forEach((line, index) => {
                    if (index === 0 && line.startsWith('#')) {
                        title = line.replace(/^#\s*/, '').trim();
                    } else if (index === 1 && line.startsWith('##')) {
                        description = line.replace(/^##\s*/, '').trim();
                    } else {
                        body += line + '\n';
                    }
                });
                
                log(`Title: ${title.substring(0, 50)}...`);
                log(`Description: ${description.substring(0, 50)}...`);
                log(`Body length: ${body.length}`);
                log(`Body has markdown links: ${/\[.+\]\(.+\)/.test(body)}`);
                log(`Body has markdown images: ${/!\[.+\]\(.+\)/.test(body)}`);
                
                document.getElementById('input').textContent = body.substring(0, 500) + '...';
                
                // Render
                log('Calling renderMarkdown...');
                const rendered = renderMarkdown(body, 'conferences/cyber-toronto/2025/december');
                
                log(`Rendered length: ${rendered.length}`);
                log(`Has <a> tags: ${rendered.includes('<a href=')}`);
                log(`Has <img> tags: ${rendered.includes('<img src=')}`);
                log(`Has raw markdown []: ${/\[.+\]\(.+\)/.test(rendered)}`);
                
                const linkCount = (rendered.match(/<a href=/g) || []).length;
                const imgCount = (rendered.match(/<img src=/g) || []).length;
                log(`Link count: ${linkCount}`);
                log(`Image count: ${imgCount}`);
                
                document.getElementById('output').innerHTML = rendered;
                document.getElementById('status').textContent = '✅ Complete';
                document.getElementById('status').style.color = '#0f0';
                
            } catch (error) {
                log(`ERROR: ${error.message}`);
                log(error.stack);
                document.getElementById('status').textContent = '❌ Error: ' + error.message;
                document.getElementById('status').style.color = '#f00';
            }
        }

        // Enhanced markdown renderer (copied from content-viewer.html)
        function renderMarkdown(text, contentPath) {
            if (!contentPath) contentPath = '';
            
            let html = text;
            
            // Handle code blocks first (preserve them)
            const codeBlocks = [];
            html = html.replace(/```[\s\S]*?```/g, (match) => {
                codeBlocks.push(match);
                return `<!--CODE_BLOCK_${codeBlocks.length - 1}-->`;
            });
            
            // Process markdown images: ![alt](url) - convert to placeholders first
            const imagePlaceholders = [];
            html = html.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, (match, alt, src) => {
                // Make relative paths absolute
                if (!src.startsWith('http') && !src.startsWith('//')) {
                    src = `${contentPath}/${src}`;
                }
                const placeholder = `<!--IMAGE_${imagePlaceholders.length}-->`;
                imagePlaceholders.push(`<img src="${src}" alt="${alt}" style="max-width:100%;height:auto;border-radius:8px;margin:20px 0;box-shadow:0 4px 12px rgba(0,0,0,0.1);">`);
                return placeholder;
            });
            
            // Process existing HTML img tags - fix relative paths
            html = html.replace(/<img([^>]*)src=["']([^"']+)["']([^>]*)>/gi, (match, before, src, after) => {
                if (!src.startsWith('http') && !src.startsWith('//') && !src.startsWith('data:')) {
                    src = `${contentPath}/${src}`;
                }
                return `<img${before}src="${src}"${after} style="max-width:100%;height:auto;border-radius:8px;margin:20px 0;box-shadow:0 4px 12px rgba(0,0,0,0.1);">`;
            });
            
            // Convert links - handle markdown links [text](url) BEFORE headers
            html = html.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" target="_blank" rel="noopener noreferrer">$1</a>');
            
            // Convert headers (after links so header links work)
            html = html.replace(/^#### (.*$)/gim, '<h4>$1</h4>');
            html = html.replace(/^### (.*$)/gim, '<h3>$1</h3>');
            html = html.replace(/^## (.*$)/gim, '<h2>$1</h2>');
            html = html.replace(/^# (.*$)/gim, '<h1>$1</h1>');
            
            // Convert bold and italic
            html = html.replace(/\*\*\*(.*?)\*\*\*/g, '<strong><em>$1</em></strong>');
            html = html.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
            html = html.replace(/\*(.*?)\*/g, '<em>$1</em>');
            html = html.replace(/__(.*?)__/g, '<strong>$1</strong>');
            html = html.replace(/_(.*?)_/g, '<em>$1</em>');
            
            // Convert unordered lists
            html = html.replace(/^\* (.*$)/gim, '<li>$1</li>');
            html = html.replace(/(<li>.*<\/li>\n?)+/g, '<ul>$&</ul>');
            html = html.replace(/<\/ul>\s*<ul>/g, '');
            
            // Restore image placeholders
            imagePlaceholders.forEach((imgHtml, index) => {
                html = html.replace(`<!--IMAGE_${index}-->`, imgHtml);
            });
            
            // Restore code blocks
            codeBlocks.forEach((block, index) => {
                const code = block.replace(/```(\w+)?\n?/, '').replace(/```$/, '');
                const escapeHtml = (text) => {
                    const map = {'&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#039;'};
                    return text.replace(/[&<>"']/g, (m) => map[m]);
                };
                html = html.replace(`<!--CODE_BLOCK_${index}-->`, `<pre><code>${escapeHtml(code)}</code></pre>`);
            });
            
            // Convert remaining newlines to <br>
            html = html.replace(/\n/g, '<br>');
            
            // Clean up excessive <br> tags
            html = html.replace(/(<br>\s*){3,}/g, '<br><br>');
            
            return html;
        }

        // Run test
        test();
    </script>
</body>
</html>
